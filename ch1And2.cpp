// SECTION: compiled c++ programs
// Notes: The compiler translates your C++ code into machine language instructions. These instructions are stored in an intermediate file 
// called an object file. Object files are typically named name.o or name.obj, where name is the same name as the .cpp file it was produced from.
// For example, if your program had 3 .cpp files, the compiler would generate 3 object files. After the compiler has successfully finished, another program 
// called the linker kicks in. The linker’s job is to combine all of the object files and produce the desired output file (such as an executable file that 
// you can run). This process is called linking. If any step in the linking process fails, the linker will generate an error message describing the issue 
// and then abort. First, the linker reads in each of the object files generated by the compiler and makes sure they are valid. Second, the linker ensures 
// all cross-file dependencies are resolved properly. For example, if you define something in one .cpp file, and then use it in a different .cpp file, the 
// linker connects the two together. If the linker is unable to connect a reference to something with its definition, you’ll get a linker error, and the 
// linking process will abort. Third, the linker typically links in one or more library files, which are collections of precompiled code that have been 
// “packaged up” for reuse in other programs. Finally, the linker outputs the desired output file. Typically this will be an executable file that can be 
// launched (but it could be a library file if that’s how you’ve set up your project). Because there are multiple steps involved, the term building is often 
// used to refer to the full process of converting source code files into an executable that can be run. A specific executable produced as the result of 
// building is sometimes called a build.For complex projects, build automation tools (such as make or build2) are often used to help automate the process of 
// building programs and running automated tests. A library file is a collection of precompiled code that has been “packaged up” for reuse in other programs. 
// The C++ Standard Library is a library that ships with C++. It contains additional functionality to use in your programs




// SECTION: input and outputs
// #include <iostream>
// #include <string>
// Notes: This #include is a preprocessor directive which indicates that we would like to use the contents of the iostream library. Blank lines are
// ignored by the compiler.

// int main(){
//     std::cout << "Yo what is your name: ";
//     std::string name;
//     std::cin >> name;
//     std::cout << "Nice to meet you " << name; 
//     return 0;
// }

// SECTION: c++ version for mac with clang on c++ 17
// Run file
// ~ clang++ -std=c++17 [file].cpp -o [name]
// ~ ./[name]
// #include <iostream>

// int main() {
//   std::cout << "C++ version: " << __cplusplus << std::endl;
//   return 0;
// }

// SECTION: Statements
// Notes: A statement is a type of instruction that causes the program to perform some action. Most (but not all) statements in C++ end in a semicolon. 
// If you see a line that ends in a semicolon, it’s probably a statement. Every C++ program must have a special function named main (all lower case letters)
// 

// SECTION: Objects and variables
// Notes: When we run a program, the operating system loads the program into RAM. In C++, direct memory access is discouraged.
//  Instead, we access memory indirectly through an object. An object represents a region of storage (typically RAM or a CPU register) that can hold a value.
// rather than say “go get the value stored in mailbox number 7532”, we can say, “go get the value stored by this object” and let the compiler figure out 
// where and how to retrieve the value. This means we can focus on using objects to store and retrieve values, and not have to worry about where in memory
//  those objects are actually being placed. The process of reserving storage for an object’s use is called allocation. 

// SECTION: Assignment
// Notes: There are 5 common forms of initialization in C++:

// int a;         // default-initialization (no initializer)

// // Traditional initialization forms:
// int b = 5;     // copy-initialization (initial value after equals sign)
// int c ( 6 );   // direct-initialization (initial value in parenthesis)

// // Modern initialization forms (preferred):
// int d { 7 };   // direct-list-initialization (initial value in braces)
// int e {};      // value-initialization (empty braces)
// As of C++17, copy-initialization, direct-initialization, and direct-list-initialization behave identically in most cases. 
// We’ll cover the most relevant case where they differ below.

// In many cases, default-initialization performs no initialization, and leaves the variable with an indeterminate value 
// (a value that is not predictable, sometimes called a “garbage value”). 

// Direct-initialization is also used when values are explicitly cast to another type (e.g. via static_cast).

    // int w1 { 4.5 }; // compile error: list-init does not allow narrowing conversion

    // int w2 = 4.5;   // compiles: w2 copy-initialized to value 4
    // int w3 (4.5);   // compiles: w3 direct-initialized to value 4

    // int width {}; // value-initialization / zero-initialization to value 0

    // For class types, value-initialization (and default-initialization) may  instead initialize the object to predefined default values, which may be non-zero.

// C++17 introduced the [[maybe_unused]] attribute, which allows us to tell the compiler that we’re okay with a variable being unused.
// The compiler will not generate unused variable warnings for such variables.


// SECTION: input output stream

// Statements in our program request that output be sent to the console. However, that output is typically not sent to the console immediately. 
// Instead, the requested output “gets in line”, and is stored in a region of memory set aside to collect such requests (called a buffer). 
// Periodically, the buffer is flushed, meaning all of the data collected in the buffer is transferred to its destination (in this case, the console).

// When outputting text to the console, we typically don’t need to explicitly flush the buffer ourselves.
//  C++’s output system is designed to self-flush periodically, and it’s both simpler and more efficient to let it flush itself.

// Using std::endl is often inefficient, as it actually does two jobs: it outputs a newline (moving the cursor to the next line of the console), and it 
// flushes the buffer (which is slow). If we output multiple lines of text ending with std::endl, we will get multiple flushes, which is slow and probably 
// unnecessary.

// Even though ‘\n’ is represented in source code as two symbols, it is treated by the compiler as a single
//  linefeed (LF) character (with ASCII value 10), and thus is conventionally single quoted (unless embedded into existing double-quoted text). 

    // int x{}; // define variable x to hold user input (and value-initialize it)
    // int y{}; // define variable y to hold user input (and value-initialize it)
    // std::cin >> x >> y; // get two numbers and store in variable x and y respectively

// Section: Undefined behavior:

// When a variable that is not initialized is given a memory address to use to store data, the default value of that variable is whatever (garbage) value 
// happens to already be in that memory address! A variable that has not been given a known value (through initialization or assignment) is called an
//  uninitialized variable.

    // doNothing(x); // make the compiler think we're assigning a value to this variable

// Code implementing undefined behavior may exhibit any of the following symptoms:

// Your program produces different results every time it is run.
// Your program consistently produces the same incorrect result.
// Your program behaves inconsistently (sometimes produces the correct result, sometimes not).
// Your program seems like it’s working but produces incorrect results later in the program.
// Your program crashes, either immediately or later.
// Your program works on some compilers but not others.
// Your program works until you change some other seemingly unrelated code.
// Or, your code may actually produce the correct behavior anyway.

// 	std::cout << sizeof(int) << '\n'; // print how many bytes of memory an int value takes

// C++ reserves a set of 92 words (as of C++23) for its own use. These words are called keywords.
// C++ also defines special identifiers: override, final, import, and module. These have a specific meaning when used in certain contexts but are not
//  reserved otherwise.

// As a reminder, the name of a variable (or function, type, or other kind of item) is called an identifier. C++ gives you a lot of flexibility to name
//  identifiers as you wish. However, there are a few rules that must be followed when naming identifiers:
// The identifier can not be a keyword. Keywords are reserved.
// The identifier can only be composed of letters (lower or upper case), numbers, and the underscore character. 
// That means the name can not contain symbols (except the underscore) nor whitespace (spaces or tabs).
// The identifier must begin with a letter (lower or upper case) or an underscore. It can not start with a number.
// C++ is case sensitive, and thus distinguishes between lower and upper case letters. nvalue is different than nValue is different than NVALUE.

// Section: functions
// #include <iostream>

// void getInput(){
//     int x{};
//     int y, z {};
//     std::cout << "Please separate 3 numbers by spaces ";
//     std::cin >> x >> y >> z;
//     std::cout << "Thank you for giving me the nums " << x << ',' << y << ','<< z;
// }

// int main(){
//     getInput();

//     return 0;
// }

// in C++, functions cannot be nested

// It is a common misconception that main is always the first function that executes.
// Global variables are initialized prior to the execution of main. If the initializer for such a variable invokes a function, then that function will 
// execute prior to main.

// Your main function should return the value 0 if the program ran normally.

// The C++ standard only defines the meaning of 3 status codes: 0, EXIT_SUCCESS, and EXIT_FAILURE. 0 and EXIT_SUCCESS both mean the program executed successfully. EXIT_FAILURE means the program did not execute successfully.

// EXIT_SUCCESS and EXIT_FAILURE are preprocessor macros defined in the <cstdlib> header:

// #include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE

// int main()
// {
//     return EXIT_SUCCESS;
// }

// The status code is passed back to the operating system. 
// The OS will typically make the status code available to whichever program launched the program returning the status code. 

// The Google C++ style guide recommends using a comment to document what the unnamed parameter was:

// void doSomething(int /*count*/)
// {
// }

// Function parameters are created and initialized when the function is entered, and variables within the function body are created and initialized 
// at the point of definition. Local variables are destroyed in the opposite order of creation at the end of the set of curly braces in which it is 
// defined (or for a function parameter, at the end of the function). an object’s lifetime is defined to be the time between its creation and destruction.

// If the object is a class type object, prior to destruction, a special function called a destructor is invoked. 
// In many cases, the destructor does nothing, in which case no cost is incurred.
// Any use of an object after it has been destroyed will result in undefined behavior. 
// At some point after destruction, the memory used by the object will be deallocated (freed up for reuse).
// We say an object goes out of scope at the end of the scope (the end curly brace) in which the object was instantiated

// forward declaration

// #include <iostream>

// int add(int x, int y); // forward declaration of add() (using a function declaration)

// int main()
// {
//     std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n'; // this works because we forward declared add() above
//     return 0;
// }

// int add(int x, int y) // even though the body of add() isn't defined until here
// {
//     return x + y;
// }

// New programmers often wonder what happens if they forward declare a function but do not define it.

// The answer is: it depends. If a forward declaration is made, but the function is never called, the program will compile and run fine. However,
//  if a forward declaration is made and the function is called, but the program never defines the function, the program will compile okay, but the 
//  linker will complain that it can’t resolve the function call.

// Section: Scope

// Similarly, C++ requires that all identifiers be non-ambiguous. If two identical identifiers are introduced into the same program in a way that the compiler or 
// linker can’t tell them apart, the compiler or linker will produce an error. This error is generally referred to as a naming collision (or naming conflict).

// If the colliding identifiers are introduced into the same file, the result will be a compiler error. If the colliding identifiers are introduced into separate
//  files belonging to the same program, the result will be a linker error.

// A scope region is an area of source code where all declared identifiers are considered distinct from names declared in other scopes.
// A namespace provides another type of scope region (called namespace scope) that allows you to declare or define names inside of it for the purpose of disambiguation.

// In C++, any name that is not defined inside a class, function, or a namespace is considered to be part of an implicitly-defined namespace
//  called the global namespace (sometimes also called the global scope).

// Although variables can be defined in the global namespace, this should generally be avoided (we discuss why in lesson 7.8 -- Why (non-const) global variables
//  are evil).Although variables can be defined in the global namespace, this should generally be avoided (we discuss why in lesson 7.8 -- Why (non-const) 
// global variables are evil).

// the :: symbol is an operator called the scope resolution operator

// Section: preprocessor

// Instead, prior to compilation, each code (.cpp) file goes through a preprocessing phase. In this phase, a program called the preprocessor makes various 
// changes to the text of the code file. The preprocessor does not actually modify the original code files in any way -- rather, all changes made by the 
// preprocessor happen either temporarily in-memory or using temporary files.

// Historically, the preprocessor was a separate program from the compiler, but in modern compilers, the preprocessor may be built right 
// into the compiler itself.

// the preprocessor does have one very important role: it is what processes #include directives (which we’ll discuss more in a moment).

// When the preprocessor has finished processing a code file, the result is called a translation unit.
//  This translation unit is what is then compiled by the compiler.

// The entire process of preprocessing, compiling, and linking is called translation.

//  the preprocessor will replace #include <iostream> with the contents of the file named “iostream” and then 
// preprocess the included content and the rest of the file.

// The #define directive can be used to create a macro. In C++, a macro is a rule that defines how input text is converted into replacement output text.

// There are two basic types of macros: object-like macros, and function-like macros.

// Function-like macros act like functions, and serve a similar purpose. Their use is generally considered unsafe, 
// and almost anything they can do can be done by a normal function.

// Object-like macros can be defined in one of two ways:

// #define IDENTIFIER
// #define IDENTIFIER substitution_text

// By convention, macro names are typically all uppercase, separated by underscores.

// #include <iostream>

// #define MY_NAME "Alex"

// int main()
// {
//     std::cout << "My name is: " << MY_NAME << '\n';

//     return 0;
// }

// conditional compilation

// #include <iostream>

// #define PRINT_JOE

// int main()
// {
// #ifdef PRINT_JOE
//     std::cout << "Joe\n"; // will be compiled since PRINT_JOE is defined
// #endif

// #ifdef PRINT_BOB
//     std::cout << "Bob\n"; // will be excluded since PRINT_BOB is not defined
// #endif

//     return 0;
// }


// #if 0 // Don't compile anything starting here
//     std::cout << "Bob\n";
//     std::cout << "Steve\n";
// #endif // until this point


// Macro substitution within other preprocessor commands

// #define FOO 9 // Here's a macro substitution

// #ifdef FOO // This FOO does not get replaced with 9 because it’s part of another preprocessor directive
//     std::cout << FOO << '\n'; // This FOO gets replaced with 9 because it's part of the normal code
// #endif

// Directives are resolved before compilation, from top to bottom on a file-by-file basis.
// #define MY_NAME "Alex"

// Conventionally, header files are used to propagate a bunch of related forward declarations into a code file.

// square.h with header guards
// #ifndef SQUARE_H
// #define SQUARE_H

// int getSquareSides()
// {
//     return 4;
// }

// #endif

// wave.h:

// #ifndef WAVE_H
// #define WAVE_H

// #include "square.h"

// #endif
// main.cpp:

// #include "square.h"
// #include "wave.h"

// int main()
// {
//     return 0;
// }

// Because of this possibility for guard name conflicts, many developers recommend using a more complex/unique name in your header guards. 
// Some good suggestions are a naming convention of PROJECT_PATH_FILE_H, FILE_LARGE-RANDOM-NUMBER_H, or FILE_CREATION-DATE_H.

// Modern compilers support a simpler, alternate form of header guards using the #pragma preprocessor directive:

// #pragma once

// // your code here

// There is one known case where #pragma once will typically fail. If a header file is copied so that it exists in multiple places on the file system, 
// if somehow both copies of the header get included, header guards will successfully de-dupe the identical headers,
//  but #pragma once won’t (because the compiler won’t realize they are actually identical content).