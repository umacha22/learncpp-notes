// SECTION: compiled c++ programs
// Notes: The compiler translates your C++ code into machine language instructions. These instructions are stored in an intermediate file 
// called an object file. Object files are typically named name.o or name.obj, where name is the same name as the .cpp file it was produced from.
// For example, if your program had 3 .cpp files, the compiler would generate 3 object files. After the compiler has successfully finished, another program 
// called the linker kicks in. The linker’s job is to combine all of the object files and produce the desired output file (such as an executable file that 
// you can run). This process is called linking. If any step in the linking process fails, the linker will generate an error message describing the issue 
// and then abort. First, the linker reads in each of the object files generated by the compiler and makes sure they are valid. Second, the linker ensures 
// all cross-file dependencies are resolved properly. For example, if you define something in one .cpp file, and then use it in a different .cpp file, the 
// linker connects the two together. If the linker is unable to connect a reference to something with its definition, you’ll get a linker error, and the 
// linking process will abort. Third, the linker typically links in one or more library files, which are collections of precompiled code that have been 
// “packaged up” for reuse in other programs. Finally, the linker outputs the desired output file. Typically this will be an executable file that can be 
// launched (but it could be a library file if that’s how you’ve set up your project). Because there are multiple steps involved, the term building is often 
// used to refer to the full process of converting source code files into an executable that can be run. A specific executable produced as the result of 
// building is sometimes called a build.For complex projects, build automation tools (such as make or build2) are often used to help automate the process of 
// building programs and running automated tests. A library file is a collection of precompiled code that has been “packaged up” for reuse in other programs. 
// The C++ Standard Library is a library that ships with C++. It contains additional functionality to use in your programs




// SECTION: input and outputs
// #include <iostream>
// #include <string>
// Notes: This #include is a preprocessor directive which indicates that we would like to use the contents of the iostream library. Blank lines are
// ignored by the compiler.

// int main(){
//     std::cout << "Yo what is your name: ";
//     std::string name;
//     std::cin >> name;
//     std::cout << "Nice to meet you " << name; 
//     return 0;
// }

// SECTION: c++ version for mac with clang on c++ 17
// Run file
// ~ clang++ -std=c++17 [file].cpp -o [name]
// ~ ./[name]
// #include <iostream>

// int main() {
//   std::cout << "C++ version: " << __cplusplus << std::endl;
//   return 0;
// }

// SECTION: Statements
// Notes: A statement is a type of instruction that causes the program to perform some action. Most (but not all) statements in C++ end in a semicolon. 
// If you see a line that ends in a semicolon, it’s probably a statement. Every C++ program must have a special function named main (all lower case letters)
// 

